



git stash               # 把目前修改暫存起來，工作目錄變乾淨
git pull                # 先拉最新
git stash pop           # 把剛剛的變更套回來（可能會出現衝突，再解）
git restore Basic_Function/list/list_API.h
# 或舊版 Git:
# git checkout -- Basic_Function/list/list_API.h
git pull


加分項
支援互動式遞迴刪除（rm -r 型）

static void print_prompt(void) {
    // 先組出從 root 到 g_cwd 的路徑（簡化版，只顯示當前目錄名）
    const char *dirname = g_cwd->name;   // root 時是 "/"

    // 如果是 root：TONY_FS:/
    // 其他目錄：   TONY_FS:dirname*
    if (g_cwd == g_root) {
        printf("TONY_FS:/ > ");
    } else {
        printf("TONY_FS:%s* > ", dirname);
    }
}


自動 load dump
這是一個很好的「自動備份＋自動復原」需求，跟工廠的「自動日終盤點」一樣。​

先聚焦在 1 個概念：exit 時自動 dump。
目前 CLI 是你自己寫的迴圈，所以可以在判斷到 cmd == "exit" 那一支路徑裡，插入一段：

呼叫 file_dump_dfs(g_root, "", fp)，dump 到固定檔名（例如 .last_dump）

再結束程式

下一步，再設計「開啟程式時自動 load」，大致會是：

main() 裡先檢查 .last_dump 是否存在

若存在就呼叫 file_sys_load(".last_dump")，否則建立空的 root

你覺得先從哪一端開始寫比較直覺：
在 CLI 的 exit 分支塞 auto_dump，還是先在 m
